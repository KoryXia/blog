---
title: Hot 100
tags: [Algorithm]
category: Algorithm
cover: /img/algorithm_cover.png
description: Leetcode hot 100
data: 2025-05-13
---

# [1. 两数之和](https://leetcode.cn/problems/two-sum/)

用 Hash 表，K 是值，V 是索引。遍历数组，判断是否存在 `target - nums[i]` 的 K，存在就返回。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

# [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

用 Hash 表，K 是原字符串，V 是一个异位词的分组。遍历数组，把每个字符串排序，作为 K，然后向 V 的 List 添加字符串元素。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str: strs) {
            char[] arr = str.toCharArray();
            Arrays.sort(arr);
            String k = new String(arr);
            List<String> v = map.getOrDefault(k, new ArrayList<>());
            v.add(str);
            map.put(k, v);
        }
        return new ArrayList<>(map.values());
    }
}
```

```go
func groupAnagrams(strs []string) [][]string {
	m := map[string][]string{}
	for _, str := range strs {
		bytesSlice := []byte(str)
		slices.Sort(bytesSlice)
        key := string(bytesSlice)
        m[key] = append(m[key], str)
	}

    res := make([][]string, 0, len(m))

    for _, v := range m {
        res = append(res, v)
    }    
    return res
}
```

# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

先用 Set 对数组去重，然后遍历不重复元素，判断是否存在 `curr + 1` 的元素，有就计数器加一。遍历时候要去重复，判断 `num - 1` 是否已经被统计过。

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();

        for (int num : nums) {
            set.add(num);
        }

        int res = 0;
        for (int num : set) {
            if (!set.contains(num - 1)) {
                int count = 1;
                int curr = num;
                while (set.contains(curr + 1)) {
                    curr++;
                    count++;
                }
                res = Math.max(res, count);
            }
        }
        return res;
    }
}
```

# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

双指针法，每次都进行复制，一个指针一直移动，另一个指针当且仅当遍历元素不是 0 的时移动。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            nums[j] = nums[i];
            if (nums[i] != 0) {
                j++;
            }
        }
        for (int i = j; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

左右双指针，每次计算水容量，只移动高度低的一侧的指针，因为宽度一直在减下，必须要寻找更大的高度，才能盛更多的水。

```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int res = 0;
        while (l < r) {
            res = Math.max(res, (r - l) * Math.min(height[l], height[r]));
            if (height[l] < height[r]) {
                res = Math.max(res, (r - l) * height[l]);
                int curr = height[l];
                while (curr >= height[l] && l < r) {
                    l++;
                }
            } else {
                res = Math.max(res, (r - l) * height[r]);
                int curr = height[r];
                while (curr >= height[r] && l < r) {
                    r--;
                }
            }
        }       
        return res;
    }
}
```

# [15. 三数之和](https://leetcode.cn/problems/3sum/)

1. 先排序
2. 固定一个元素，判断是否已经不符合条件（>0），然后跳过重复元素（nums[i] == nums[i - 1]）。
3. 双指针查询，找到符合条件的后，需要移动指针，移动过程中需要去重。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 2; i++) {
            if (nums[i] > 0) break;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int l = i + 1;
            int r = nums.length - 1;
            while (l < r) {
                int sum = nums[l] + nums[r] + nums[i];
                if (sum == 0) {
                    while(l < r && nums[r] == nums[r - 1]) {
                        r--;
                    }
                    while(l < r && nums[l] == nums[l + 1]) {
                        l++;
                    }
                    res.add(List.of(nums[l], nums[r], nums[i]));
                    l++;
                    r--;
                } else if (sum > 0) {
                    r--;
                } else {
                    l++;
                }
            }
        }
        return res;
    }
}
```

# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

单调栈实现，小于就入栈，等于就更新，大于开始接雨水。

接：推出栈顶当作底部，然后栈顶和遍历元素就是左右两边，然后计算容量，注意是 while 循环，还要继续接更左侧的水。

```java
class Solution {
    public int trap(int[] height) {
        if (height.length < 2)
            return 0;
        int res = 0;
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(0);
        for (int i = 1; i < height.length; i++) {
            int top = stack.peek();
            if (height[i] > height[top]) {
                while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                    int bottom = stack.pop();
                    if (!stack.isEmpty()) {
                        int left = stack.peek();
                        int h = Math.min(height[left], height[i]) - height[bottom];
                        int w = i - left - 1;
                        res += w * h;
                    }
                }
            }
            stack.push(i);
        }
        return res;
    }
}
```

双指针法，两次靠近，较小的一侧水平兜住，能明确了，大的一次还需要判断。注意 l <= r

```java
class Solution {
    public int trap(int[] height) {
        if (height.length <= 2) {
            return 0;
        }

        int maxLeft = height[0], maxRight = height[height.length - 1];
        int l = 1, r = height.length - 2;
        int res = 0;
        while (l <= r) {
            maxLeft = Math.max(maxLeft, height[l]);
            maxRight = Math.max(maxRight, height[r]);
            if (maxLeft < maxRight) {
                res += maxLeft - height[l++];
            } else {
                res += maxRight - height[r--];
            }
        }
        return res;
    }
}

```

