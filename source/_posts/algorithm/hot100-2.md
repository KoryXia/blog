---
title: Hot 100
tags: [Algorithm]
category: Algorithm
cover: /img/algorithm_cover.png
description: Leetcode hot 100
data: 2025-05-18
---

# [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

用双指针，prev 和 end，当 end 不为 null 时候，就不断翻转。

前 end 移动 k 个，如果 end 已经是 null了，就 break。

然后设置一个 start，指向反转数组头部，next 指针，指向 end 后续部分。

然后把 end 后续断开，防止翻转多了，随后用 start 为头节点翻转链表。

反转后 start 变成子链表的尾节点了。

之后 start.next = next 接上断开的部分。

start 和 end 指针更新到 k 个一组的末尾。

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0, head);
        ListNode prev = dummy;
        ListNode end = dummy;

        while (end != null) {
            for (int i = 0; i < k && end != null; i++) {
                end = end.next;
            }
            if (end == null) {
                break;
            }
            ListNode start = prev.next;
            ListNode next = end.next;
            end.next = null;
            prev.next = reverse(start);
            start.next = next;
            end = start;
            prev = start;
        }
        return dummy.next;
    }

    public ListNode reverse(ListNode head) {
        ListNode prev = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
```

# [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

先把每个节点的指包装新的节点放入 map 中。

然后再遍历，简历 next 和 random 指针。

最后返回 key 为 head 的节点。

```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node, Node> map = new HashMap<>();
        Node cur = head;
        while (cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }

        cur = head;
        while (cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
```

# [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        res.addAll(inorderTraversal(root.left));
        res.add(root.val);
        res.addAll(inorderTraversal(root.right));
        return res;
    }
}
```

# [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

每次递归左右最大深度加一，后序遍历。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }

        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;

        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

# [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

放入对称轴左右两次进行比较，判断不同的情况，如果对称机继续递归。

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        } else if (left != null && right == null) {
            return false;
        } else if (left == null && right != null) {
            return false;
        } else if (left.val != right.val) {
            return false;
        }

        boolean leftRes = compare(left.left, right.right);
        boolean rightRes = compare(left.right, right.left); 
        return leftRes && rightRes;
    }
}
```

# [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

就是统计两边最大深度的和加一，最后返回值再减一。

```java
class Solution {
    private int res;
    public int diameterOfBinaryTree(TreeNode root) {
        traverse(root);
        return res - 1;
    }

    public int traverse(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = traverse(root.left);
        int right = traverse(root.right);
        res = Math.max(res, left + right + 1);
        return Math.max(left, right) + 1;
    }
}
```

# [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                } 
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            res.add(level);
        }
        return res;
    }
}
```

# [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

二叉搜索数节点大于左节点，小于右节点，中序遍历是递增的，数组中间值就是 

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traverse(nums, 0, nums.length - 1);
    }

    public TreeNode traverse(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = traverse(nums, left, mid - 1);
        node.right = traverse(nums, mid + 1, right);
        return node;
    }
}
```

# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

中序遍历，用一个变量保存前一个节点的值，判断当前节点是否大于前一节点，不正确就直接返回 false。

```java
class Solution {
    private Integer prev = null;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        if (!isValidBST(root.left)) {
            return false;
        }
        
        if (prev != null && root.val <= prev) {
            return false;
        }
        prev = root.val;

        return isValidBST(root.right);   
    }
}
```

# [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

中序遍历，用全局计数器，记录遍历的数量，当计数器等于 0，就是结果。

```java
class Solution {
    private int res;
    private int i;
    public int kthSmallest(TreeNode root, int k) {
        i = k;
        traverse(root, k);
        return res;
    }
    public void traverse(TreeNode node, int k) {
        if (node == null) {
            return;
        }

        traverse(node.left, k);
        i--;
        if (i == 0) {
            res = node.val;
            return;
        }
        traverse(node.right, k);
    }
}
```

# [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

层序遍历，只添加每层最后一个元素。或者前序遍历，优先获得首次访问该层的右侧节点。

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            res.add(level.get(level.size() - 1));
        }
        return res;
    }
}
```

```java
    List<Integer> res = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0);
        return res;
    }

    void dfs(TreeNode root, int depth) {
        if (root == null) {
            return;
        }

        // 只有第一次到达这一层时才会添加节点
        if (res.size() == depth) {
            res.add(root.val);
        }

        // 优先访问右子树
        dfs(root.right, depth + 1);
        dfs(root.left, depth + 1);
    }
```

# [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

后续遍历，先把左右变成右侧的链表，然后处理中间节点，把左节点变成右节点，再找到新右节点的终点，把旧的右节点接上。

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) {
            return;
        }

        flatten(root.left);
        flatten(root.right);

        TreeNode rightNode = root.right;
        root.right = root.left;
        root.left = null;
        TreeNode cur = root;
        while(cur.right != null) {
            cur = cur.right;
        }
        cur.right = rightNode;
    }
}
```

# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

1. 构建中序映射。
2. 从前序列表获取根节点。
3. 从中序映射获取根节点中序列表位置，将中序列表分为左子树和右子树。
4. 构建左右子树。

```java
public class Solution {
    private Map<Integer, Integer> inorderMap;
    private int preIndex = 0;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 构建中序索引表
        inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        // 开始构建树
        return build(preorder, 0, inorder.length - 1);
    }

    private TreeNode build(int[] preorder, int inLeft, int inRight) {
        // 如果当前子树范围无效，返回空节点
        if (inLeft > inRight) {
            return null;
        }

        // 1. 从前序数组找到根节点
        int rootValue = preorder[preIndex];
        preIndex++;
        TreeNode root = new TreeNode(rootValue);
        
        // 2. 找到根节点在中序遍历中的位置
        int rootIndex = inorderMap.get(rootValue);
        
        // 3. 构建左子树
        root.left = build(preorder, inLeft, rootIndex - 1);
        
        // 4. 构建右子树
        root.right = build(preorder, rootIndex + 1, inRight);
        
        return root;
    }
}
```

# [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

后序遍历

1. **递归终止条件**
   - `root == null`：走到空节点，返回 `null`。
   - `root == p` 或 `root == q`：找到 `p` 或 `q`，返回当前节点。
2. **在左右子树查找**
   - 递归查找左右子树中的 `p` 和 `q`。
3. **返回逻辑**
   - **左右子树都找到**：说明 `p` 和 `q` 分布在左右两侧，当前节点就是 LCA。
   - **只找到一个**：返回非空的节点。
   - **都没找到**：返回 `null`。

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == q || root == p) {
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.left, p, q);
        if (left != null && right != null) {
            return root;
        } else if (left != null && right == null) {
            return left;
        } else if (left == null && right != null) {
            return right;
        } else {
            return null;
        }
    }
}
```

